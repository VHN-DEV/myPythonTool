#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Tool: Backup th∆∞ m·ª•c v·ªõi timestamp v√† t√≠nh nƒÉng n√¢ng cao

M·ª•c ƒë√≠ch: Sao l∆∞u d·ªØ li·ªáu quan tr·ªçng
L√Ω do: B·∫£o v·ªá d·ªØ li·ªáu kh·ªèi m·∫•t m√°t
"""

import os
import sys
import shutil
import datetime
import json
import argparse
from pathlib import Path
from typing import List, Optional, Tuple

# Th√™m th∆∞ m·ª•c cha v√†o sys.path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from utils import (
    print_header, format_size, get_user_input, confirm_action,
    get_folder_size, ensure_directory_exists, ProgressBar,
    log_info, log_error, setup_logger
)


class BackupManager:
    """
    Class qu·∫£n l√Ω backup
    
    M·ª•c ƒë√≠ch: T·∫≠p trung logic backup, d·ªÖ m·ªü r·ªông v√† maintain
    """
    
    def __init__(self, source_folder: str, backup_location: str):
        """
        Kh·ªüi t·∫°o BackupManager
        
        Args:
            source_folder: Th∆∞ m·ª•c ngu·ªìn c·∫ßn backup
            backup_location: V·ªã tr√≠ l∆∞u backup
        """
        self.source_path = Path(source_folder).resolve()
        self.backup_location = Path(backup_location).resolve()
        self.metadata_file = self.backup_location / "backup_metadata.json"
        
        # ƒê·∫£m b·∫£o th∆∞ m·ª•c backup t·ªìn t·∫°i
        ensure_directory_exists(str(self.backup_location))
    
    def get_backup_metadata(self) -> dict:
        """
        ƒê·ªçc metadata c·ªßa c√°c backup tr∆∞·ªõc
        
        Returns:
            dict: Metadata c·ªßa c√°c backup
        
        Gi·∫£i th√≠ch:
        - L∆∞u th√¥ng tin c√°c l·∫ßn backup (timestamp, size, file count...)
        - H·ªó tr·ª£ incremental backup trong t∆∞∆°ng lai
        """
        if self.metadata_file.exists():
            try:
                with open(self.metadata_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
            except Exception:
                return {'backups': []}
        return {'backups': []}
    
    def save_backup_metadata(self, backup_info: dict):
        """
        L∆∞u metadata c·ªßa backup m·ªõi
        
        Args:
            backup_info: Th√¥ng tin backup (timestamp, size, path...)
        
        Gi·∫£i th√≠ch:
        - Append backup info v√†o metadata file
        - Gi√∫p tracking l·ªãch s·ª≠ backup
        """
        metadata = self.get_backup_metadata()
        metadata['backups'].append(backup_info)
        
        # Gi·ªØ t·ªëi ƒëa 50 records g·∫ßn nh·∫•t
        if len(metadata['backups']) > 50:
            metadata['backups'] = metadata['backups'][-50:]
        
        with open(self.metadata_file, 'w', encoding='utf-8') as f:
            json.dump(metadata, f, indent=2, ensure_ascii=False)
    
    def list_previous_backups(self) -> List[dict]:
        """
        Li·ªát k√™ c√°c backup tr∆∞·ªõc
        
        Returns:
            list: Danh s√°ch backup info
        """
        metadata = self.get_backup_metadata()
        return metadata.get('backups', [])
    
    def create_backup(
        self,
        compression_format: str = 'zip',
        exclude_patterns: Optional[List[str]] = None,
        show_progress: bool = True
    ) -> Tuple[bool, str, dict]:
        """
        T·∫°o backup th∆∞ m·ª•c
        
        Args:
            compression_format: ƒê·ªãnh d·∫°ng n√©n (zip, tar, gztar, bztar, xztar)
            exclude_patterns: Danh s√°ch pattern c·∫ßn lo·∫°i tr·ª´
            show_progress: Hi·ªÉn th·ªã progress bar
        
        Returns:
            tuple: (success, backup_file_path, backup_info)
        
        Gi·∫£i th√≠ch:
        - T√≠nh dung l∆∞·ª£ng th∆∞ m·ª•c ngu·ªìn
        - Copy file v·ªõi exclude patterns
        - N√©n th√†nh archive
        - L∆∞u metadata
        """
        try:
            # Ki·ªÉm tra th∆∞ m·ª•c ngu·ªìn
            if not self.source_path.exists():
                return False, "", {"error": "Th∆∞ m·ª•c ngu·ªìn kh√¥ng t·ªìn t·∫°i"}
            
            # T·∫°o t√™n backup
            folder_name = self.source_path.name
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_name = f"{folder_name}_backup_{timestamp}"
            
            log_info(f"B·∫Øt ƒë·∫ßu backup: {self.source_path}")
            
            # T√≠nh dung l∆∞·ª£ng (v·ªõi progress)
            print(f"üìä ƒêang t√≠nh dung l∆∞·ª£ng...")
            total_size = get_folder_size(str(self.source_path))
            print(f"   Dung l∆∞·ª£ng: {format_size(total_size)}")
            log_info(f"Dung l∆∞·ª£ng ngu·ªìn: {format_size(total_size)}")
            
            # N·∫øu c√≥ exclude patterns
            if exclude_patterns:
                print(f"\nüì¶ ƒêang copy v√† lo·∫°i tr·ª´...")
                backup_file = self._backup_with_exclude(
                    backup_name, exclude_patterns, compression_format, show_progress
                )
            else:
                print(f"\nüì¶ ƒêang n√©n...")
                backup_file = self._backup_full(
                    backup_name, compression_format, show_progress
                )
            
            if not backup_file:
                return False, "", {"error": "L·ªói khi t·∫°o backup"}
            
            # L·∫•y th√¥ng tin backup
            backup_size = os.path.getsize(backup_file)
            compression_ratio = (backup_size / total_size * 100) if total_size > 0 else 0
            
            # T·∫°o backup info
            backup_info = {
                'timestamp': timestamp,
                'source_path': str(self.source_path),
                'backup_file': os.path.basename(backup_file),
                'original_size': total_size,
                'compressed_size': backup_size,
                'compression_ratio': compression_ratio,
                'format': compression_format,
                'excluded_patterns': exclude_patterns or []
            }
            
            # L∆∞u metadata
            self.save_backup_metadata(backup_info)
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            print(f"\n‚úÖ Backup th√†nh c√¥ng!")
            print(f"   üìÅ Th∆∞ m·ª•c ngu·ªìn: {self.source_path}")
            print(f"   üíæ File backup: {backup_file}")
            print(f"   üìä K√≠ch th∆∞·ªõc g·ªëc: {format_size(total_size)}")
            print(f"   üìä K√≠ch th∆∞·ªõc n√©n: {format_size(backup_size)}")
            print(f"   üíØ T·ª∑ l·ªá n√©n: {compression_ratio:.1f}%")
            
            log_info(f"Backup th√†nh c√¥ng: {backup_file}")
            
            return True, backup_file, backup_info
            
        except Exception as e:
            error_msg = f"L·ªói khi backup: {e}"
            print(f"‚ùå {error_msg}")
            log_error(error_msg, exc_info=True)
            return False, "", {"error": str(e)}
    
    def _backup_full(
        self,
        backup_name: str,
        compression_format: str,
        show_progress: bool
    ) -> Optional[str]:
        """
        Backup to√†n b·ªô kh√¥ng c√≥ exclude
        
        Args:
            backup_name: T√™n backup
            compression_format: Format n√©n
            show_progress: Hi·ªÉn th·ªã progress
        
        Returns:
            str: ƒê∆∞·ªùng d·∫´n file backup
        
        Gi·∫£i th√≠ch:
        - S·ª≠ d·ª•ng shutil.make_archive cho backup nhanh
        - Kh√¥ng c·∫ßn copy trung gian
        """
        backup_file_base = self.backup_location / backup_name
        
        try:
            backup_file = shutil.make_archive(
                str(backup_file_base),
                compression_format,
                self.source_path.parent,
                self.source_path.name
            )
            return backup_file
        except Exception as e:
            log_error(f"L·ªói khi n√©n: {e}")
            return None
    
    def _backup_with_exclude(
        self,
        backup_name: str,
        exclude_patterns: List[str],
        compression_format: str,
        show_progress: bool
    ) -> Optional[str]:
        """
        Backup v·ªõi exclude patterns
        
        Args:
            backup_name: T√™n backup
            exclude_patterns: Danh s√°ch patterns c·∫ßn lo·∫°i tr·ª´
            compression_format: Format n√©n
            show_progress: Hi·ªÉn th·ªã progress
        
        Returns:
            str: ƒê∆∞·ªùng d·∫´n file backup
        
        Gi·∫£i th√≠ch:
        - Copy file v√†o th∆∞ m·ª•c t·∫°m v·ªõi ignore patterns
        - N√©n th∆∞ m·ª•c t·∫°m
        - X√≥a th∆∞ m·ª•c t·∫°m
        """
        temp_folder = self.backup_location / f"temp_{backup_name}"
        
        try:
            # H√†m ignore patterns
            def ignore_patterns(directory, contents):
                ignored = set()
                for pattern in exclude_patterns:
                    for item in contents:
                        # Kh·ªõp pattern trong t√™n file/folder
                        if pattern.lower() in item.lower():
                            ignored.add(item)
                return ignored
            
            # Copy v·ªõi progress
            if show_progress:
                # ƒê·∫øm s·ªë file ƒë·ªÉ hi·ªÉn th·ªã progress
                total_files = sum(1 for _ in self.source_path.rglob('*') if _.is_file())
                progress = ProgressBar(total_files, prefix="Copy file:")
                
                # Custom copytree v·ªõi callback
                self._copytree_with_progress(
                    self.source_path,
                    temp_folder,
                    ignore=ignore_patterns,
                    progress=progress
                )
                progress.finish("Copy ho√†n th√†nh")
            else:
                shutil.copytree(self.source_path, temp_folder, ignore=ignore_patterns)
            
            # N√©n th∆∞ m·ª•c t·∫°m
            backup_file = shutil.make_archive(
                str(self.backup_location / backup_name),
                compression_format,
                temp_folder.parent,
                temp_folder.name
            )
            
            # X√≥a th∆∞ m·ª•c t·∫°m
            shutil.rmtree(temp_folder)
            
            return backup_file
            
        except Exception as e:
            # Cleanup th∆∞ m·ª•c t·∫°m n·∫øu l·ªói
            if temp_folder.exists():
                try:
                    shutil.rmtree(temp_folder)
                except Exception:
                    pass
            
            log_error(f"L·ªói khi backup v·ªõi exclude: {e}")
            return None
    
    def _copytree_with_progress(
        self,
        src: Path,
        dst: Path,
        ignore=None,
        progress: Optional[ProgressBar] = None
    ):
        """
        Copy tree v·ªõi progress tracking
        
        Args:
            src: Source path
            dst: Destination path
            ignore: Ignore function
            progress: Progress bar instance
        
        Gi·∫£i th√≠ch:
        - Custom implementation c·ªßa copytree
        - C·∫≠p nh·∫≠t progress sau m·ªói file copy
        """
        dst.mkdir(parents=True, exist_ok=True)
        
        for item in src.iterdir():
            s = src / item.name
            d = dst / item.name
            
            # Check ignore
            if ignore:
                ignored = ignore(str(src), [item.name])
                if item.name in ignored:
                    continue
            
            if s.is_dir():
                self._copytree_with_progress(s, d, ignore, progress)
            else:
                shutil.copy2(str(s), str(d))
                if progress:
                    progress.update()
    
    def restore_backup(self, backup_file: str, restore_location: str) -> bool:
        """
        Kh√¥i ph·ª•c t·ª´ backup
        
        Args:
            backup_file: File backup c·∫ßn restore
            restore_location: V·ªã tr√≠ restore
        
        Returns:
            bool: Th√†nh c√¥ng hay kh√¥ng
        
        Gi·∫£i th√≠ch:
        - Gi·∫£i n√©n backup v√†o v·ªã tr√≠ ch·ªâ ƒë·ªãnh
        - H·ªó tr·ª£ restore t·ª´ c√°c backup c≈©
        """
        try:
            print(f"üì¶ ƒêang gi·∫£i n√©n...")
            shutil.unpack_archive(backup_file, restore_location)
            print(f"‚úÖ Restore th√†nh c√¥ng v√†o: {restore_location}")
            log_info(f"Restore th√†nh c√¥ng: {backup_file} -> {restore_location}")
            return True
        except Exception as e:
            print(f"‚ùå L·ªói khi restore: {e}")
            log_error(f"L·ªói restore: {e}", exc_info=True)
            return False


def main_interactive():
    """
    Ch·∫ø ƒë·ªô interactive
    
    Gi·∫£i th√≠ch:
    - H·ªèi ng∆∞·ªùi d√πng t·ª´ng b∆∞·ªõc
    - Hi·ªÉn th·ªã menu l·ª±a ch·ªçn
    """
    print_header("TOOL BACKUP TH∆Ø M·ª§C")
    
    # Menu ch√≠nh
    print("===== MENU CH√çNH =====")
    print("1. T·∫°o backup m·ªõi")
    print("2. Xem l·ªãch s·ª≠ backup")
    print("3. Restore t·ª´ backup")
    print("0. Tho√°t")
    
    choice = get_user_input("\nCh·ªçn ch·ª©c nƒÉng (0-3)", default="1")
    
    if choice == "0":
        print("Tho√°t ch∆∞∆°ng tr√¨nh.")
        return
    
    # Nh·∫≠p th∆∞ m·ª•c ngu·ªìn
    source_input = get_user_input("Nh·∫≠p ƒë∆∞·ªùng d·∫´n th∆∞ m·ª•c c·∫ßn backup")
    if not source_input or not os.path.isdir(source_input):
        print("‚ùå Th∆∞ m·ª•c kh√¥ng t·ªìn t·∫°i!")
        return
    
    # Nh·∫≠p v·ªã tr√≠ backup
    backup_input = get_user_input(
        "Nh·∫≠p v·ªã tr√≠ l∆∞u backup (Enter ƒë·ªÉ l∆∞u t·∫°i th∆∞ m·ª•c hi·ªán t·∫°i)",
        default="."
    )
    
    # Kh·ªüi t·∫°o BackupManager
    manager = BackupManager(source_input, backup_input)
    
    if choice == "1":
        # T·∫°o backup m·ªõi
        print("\n===== CH·∫æ ƒê·ªò BACKUP =====")
        print("1. Backup to√†n b·ªô")
        print("2. Backup c√≥ lo·∫°i tr·ª´ (exclude)")
        
        mode = get_user_input("Ch·ªçn ch·∫ø ƒë·ªô (1-2)", default="1")
        
        # Ch·ªçn ƒë·ªãnh d·∫°ng n√©n
        print("\n===== ƒê·ªäNH D·∫†NG N√âN =====")
        print("1. ZIP (ph·ªï bi·∫øn, nhanh)")
        print("2. TAR")
        print("3. TAR.GZ (n√©n cao h∆°n)")
        print("4. TAR.BZ2 (n√©n cao nh·∫•t, ch·∫≠m h∆°n)")
        
        format_choice = get_user_input("Ch·ªçn ƒë·ªãnh d·∫°ng (1-4, Enter ƒë·ªÉ m·∫∑c ƒë·ªãnh ZIP)", default="1")
        
        format_map = {
            "1": "zip",
            "2": "tar",
            "3": "gztar",
            "4": "bztar"
        }
        
        compression = format_map.get(format_choice, "zip")
        
        # Exclude patterns
        exclude_patterns = None
        if mode == "2":
            exclude_input = get_user_input(
                "\nNh·∫≠p c√°c pattern c·∫ßn lo·∫°i tr·ª´ (c√°ch nhau b·ªüi d·∫•u ph·∫©y, vd: node_modules,.git,__pycache__)",
                default="node_modules,.git,__pycache__,.vscode,.idea,venv,env,dist,build"
            )
            exclude_patterns = [p.strip() for p in exclude_input.split(',') if p.strip()]
            
            if exclude_patterns:
                print(f"\nüö´ Lo·∫°i tr·ª´: {', '.join(exclude_patterns)}")
        
        # X√°c nh·∫≠n
        if not confirm_action("B·∫Øt ƒë·∫ßu backup?"):
            print("‚ùå ƒê√£ h·ªßy")
            return
        
        # Th·ª±c hi·ªán backup
        print(f"\nüöÄ B·∫Øt ƒë·∫ßu backup...\n")
        success, backup_file, info = manager.create_backup(
            compression_format=compression,
            exclude_patterns=exclude_patterns,
            show_progress=True
        )
        
        if success:
            print(f"\nüéâ Backup ƒë√£ ƒë∆∞·ª£c l∆∞u t·∫°i: {backup_file}")
    
    elif choice == "2":
        # Xem l·ªãch s·ª≠ backup
        print("\n===== L·ªäCH S·ª¨ BACKUP =====")
        backups = manager.list_previous_backups()
        
        if not backups:
            print("Ch∆∞a c√≥ backup n√†o.")
            return
        
        for idx, backup in enumerate(backups[-10:], 1):  # 10 backup g·∫ßn nh·∫•t
            print(f"\n{idx}. {backup['timestamp']}")
            print(f"   File: {backup['backup_file']}")
            print(f"   K√≠ch th∆∞·ªõc: {format_size(backup['compressed_size'])}")
            print(f"   T·ª∑ l·ªá n√©n: {backup['compression_ratio']:.1f}%")
            if backup.get('excluded_patterns'):
                print(f"   Lo·∫°i tr·ª´: {', '.join(backup['excluded_patterns'])}")
    
    elif choice == "3":
        # Restore t·ª´ backup
        print("\n===== RESTORE T·ª™ BACKUP =====")
        
        backup_file = get_user_input("Nh·∫≠p ƒë∆∞·ªùng d·∫´n file backup")
        if not os.path.isfile(backup_file):
            print("‚ùå File backup kh√¥ng t·ªìn t·∫°i!")
            return
        
        restore_location = get_user_input("Nh·∫≠p v·ªã tr√≠ restore", default="./restored")
        
        if not confirm_action("B·∫Øt ƒë·∫ßu restore?", require_yes=True):
            print("‚ùå ƒê√£ h·ªßy")
            return
        
        manager.restore_backup(backup_file, restore_location)


def main_cli(args):
    """
    Ch·∫ø ƒë·ªô CLI
    
    Args:
        args: Arguments t·ª´ argparse
    """
    manager = BackupManager(args.source, args.output)
    
    exclude_patterns = None
    if args.exclude:
        exclude_patterns = [p.strip() for p in args.exclude.split(',')]
    
    success, backup_file, info = manager.create_backup(
        compression_format=args.format,
        exclude_patterns=exclude_patterns,
        show_progress=not args.quiet
    )
    
    if success:
        print(f"‚úÖ Backup: {backup_file}")
        return 0
    else:
        print(f"‚ùå L·ªói: {info.get('error', 'Unknown')}")
        return 1


def main():
    """H√†m main"""
    # Setup logger
    setup_logger('backup-folder', log_to_console=False)
    
    # Argument parser
    parser = argparse.ArgumentParser(
        description='Tool backup th∆∞ m·ª•c v·ªõi n√©n',
        epilog="""
V√≠ d·ª•:
  # Interactive mode
  python backup-folder.py
  
  # Backup v·ªõi ZIP
  python backup-folder.py -s ./project -o ./backups
  
  # Backup v·ªõi exclude
  python backup-folder.py -s ./project -o ./backups -e "node_modules,.git,__pycache__"
  
  # Backup v·ªõi TAR.GZ
  python backup-folder.py -s ./project -o ./backups -f gztar
        """
    )
    
    parser.add_argument('-s', '--source', help='Th∆∞ m·ª•c ngu·ªìn')
    parser.add_argument('-o', '--output', help='Th∆∞ m·ª•c ƒë·∫ßu ra')
    parser.add_argument('-f', '--format', default='zip',
                       choices=['zip', 'tar', 'gztar', 'bztar', 'xztar'],
                       help='ƒê·ªãnh d·∫°ng n√©n (m·∫∑c ƒë·ªãnh: zip)')
    parser.add_argument('-e', '--exclude', help='Patterns lo·∫°i tr·ª´ (ph√¢n c√°ch b·ªüi d·∫•u ph·∫©y)')
    parser.add_argument('-q', '--quiet', action='store_true', help='Kh√¥ng hi·ªÉn th·ªã progress')
    
    args, unknown = parser.parse_known_args()
    
    if args.source:
        sys.exit(main_cli(args))
    else:
        try:
            main_interactive()
        except KeyboardInterrupt:
            print("\n\n‚ùå ƒê√£ h·ªßy!")
        except Exception as e:
            print(f"\n‚ùå L·ªói: {e}")
            log_error(f"Exception: {e}", exc_info=True)


if __name__ == "__main__":
    main()
